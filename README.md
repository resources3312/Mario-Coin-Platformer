# Mario Coin Platformer

**Mario Coin Platformer** — представляет собой небольшой платформер в стилистике серии игр Mario, построенный на базе библиотеки **Arcade**, языка программирования Python.

Данный платформер был создан для демонстрации базовых концепций библиотеки **Arcade**, однако также содержит в себе примеры использования **Tiled Map Editor**, ведь даже при создании простейших платформеров, использование конструкторов уровней является абсолютной необходимостью

# Что такое Arcade

**Arcade** — библиотека языка программирования Python с открытым исходным кодом, предоставляющая интуитивно понятный функционал для создания 2D-игр. Благодаря низкому порогу входа отлично подходит для первого знакомства с разработкой игр, или быстрому созданию прототипов для дальнейшей реализации проектов на более сложных инструментах

### Установка библиотеки
Данная библиотека доступна к скачиванию через пакетный менеджер **Pip**, поэтому ее установка может быть проведена одной командой

**Установка библиотеки arcade через Pip**
```bash
pip install arcade
```

# Создание макета уровня

Перед тем как приступить к использованию библиотеки **Arcade** для реализации логики игры, необходимо создать макет основного уровня игры, на котором будут размещены спрайты данного платформера.

При создании локаций рассматриваемой игры будет использован конструктор уровней **Tiled Map Editor**, который построен на концепции так называемых тайлов, и отлично подходит для создания локаций в играх подобного типа.

### Установка Tiled Map Editor
Данный инструмент доступен для скачивания с [официального сайта](https://www.mapeditor.org/) и имеет версии под большинство современных платформ. Процесс установки весьма тривиален, поэтому не будет подробно рассматриваться в рамках данного руководства


![Страница загрузки Tiled Map Editor](./images/download.png)
_Страница загрузки Tiled Map Editor_

## Создание новой карты
![Главное меню](./images/main_menu.png)
_Главное меню Tiled Map Editor_

После завершения процесса установки и запуска Tiled Map Editor мы можем наблюдать главное меню меню данной программы. Для начала работы нам необходимо создать карту, что можно сделать через действие NewMap, которое находится по пути **Файл>Новый>Новая карта....**

![Диалоговое окно создания карты](./images/create_map.png)
_Диалоговое окно создания карты_

После выбора данного пункта меню на экране появится диалоговое окно с базовыми настройками создаваемой карты. Данный проект имеет базовые настройки карты, поэтому мы создадим карту уровня без редактирования последних.

## Загрузка спрайтов
![Рабочая область tiled map editor](./images/menu.png)
_Рабочая область Tiled Map Editor_

После успешного создания карты нам отображается рабочая область проекта в рамках которой будет проводится работа над картой уровня нашей игры 

![Меню выбора тайлов](./images/tail_menu.png)

_Меню выбора тайлов_

Для продолжения работы над картой уровня возникает необходимость в наличии спрайтов для дальнейшего распределения по доступной области тайлов.

 К использованию в качестве спрайтов доступны изображения хранящиеся в распрастраненных форматах (PNG, JPEG, и т.д), однако в нашем случае будут использованы спрайты лишь в формате PNG. Для импорта спрайтов можно воспользоваться кнопкой с подписью **"Новый набор тайлов..."**, что расположена в правом нижнем меню отвечающем за работу с наборами тайлов (**tileset**)

## Работа со слоями

После создания пустой карты уровня и импортирования необходимых наборов тайлов, мы наконец-то можем перейти к реализации отдельных составляющих карты уровня, быть точнее к созданию ее слоев.

Для создания карты уровня представленного платформера, нам потребуется 3 основных слоя

- **Слой тайлов ground** — хранящий платформы нашей игры

- **Слой тайлов coins** — хранящий монеты для дальнейшего сбора игроком

- **Объектный слой Player** — назначение которого заключается в установке точки спавна игрока

### Создание слоя

Чтобы создать новый слой необходимо кликнуть правой кнопкой мыши по списку слоев карты, что расположен в правом верхнем углу и в открывшемся меню выбрать пункт **Новый>Слой тайлов** и выбрать название созданного слоя

![Создание нового слоя](./images/create_layer.png)

_Создание нового слоя_

### Размещение тайлов

В Tiled Map Editor присутствует широкий ряд инструментов для размещения, удаления и проведения других операций с тайлами. Среди основных инструментов, которые понадобятся нам при работе со слоями можно выделить такие как:

- **Штамп (Stamp)** — базовый инструмент предназначенный для точечного размещения спрайтов внутри тайловой сетки. Также поддерживает заполнение нескольких тайлов при их выборе в меню работы с тайлами

  ![Инструмент штампа](./images/stamp.png)

- **Ластик (Eraser)** — данный инструмент используется для точечного очищения тайлов от спрайтов добавленных ранее

  ![Инструмент ластик](./images/eraser.png)
  
- **Инструмент заливки форм (Shape fill tool)** — по принципу работы схож с выделением, однако в отличии от последнего служит только для заполнения выделенной области спрайтами

  ![Инструмент заливки форм](./images/shape_fill_tool.png)

После окончания работы со слоями тайлов **ground** и **coins** должен быть получен результат подобный приложенному ниже

![Карта уровня](./images/map.png)
_Карта уровня экспортированная в формате png_

### Размещение точки спавна игрока

Заключительным шагом в создании карты является размещение точки спавна игрока на объектном слое. Для этого нам необходимо создать объектный слой, что можно сделать с помощью пункта меню **Новый>Слой объектов** в виджете управления слоями

![Создание объектного слоя](./images/create_obj_layer.png)

_Создание объектного слоя_

Теперь нам необходимо обозначить точку спавна на одном из тайлов объектного слоя, что можно сделать с помощью инструмента прямоугольника, расположение которого в панели инструментов представлено ниже

![Инструмент прямоугольника](./images/rectangle_tool.png)

_Прямоугольник на панели инструментов_

### Экспорт тайловой карты
После создания карты уровня игры и установки точки появления игрока, карту необходимо экспортировать в формате **tmx**, для дальнейшего использования в рамках данного проекта. Чтобы провести операцию экспорта карты, нужно воспользоваться пунктом меню **Файл>Экспортировать как**

![Экспорт карты уровня](./images/export_menu.png)

_Экспорт карты уровня в формате tmx_

# Написание игровой логики

В предыдущем разделе был рассмотрен пример создания простейшей карты уровня с платформами и монетами для сбора игроком. Однако для того, чтобы на основе реализованной карты создать полноценный платформер, необходимо описать игровую логику с помощью упомянутой ранее библиотеки Arcade, а также создать правильную иерархию проекта для упорядоченного хранения необходимых ресурсов. За некоторыми исключениями проекты подобного типа имеют следующую структуру:
```Game structure
 |— Game
 |  |
 |  |–– MarioPlatformer.py
 |  |
 |  |-- res
 |  |   |
 |      |– maps/
 |      |  | 
 |      |  |— map.tmx
 |      |  |
 |      |
 |      |– images
 |      |  |
 |      |  |– sprites..
 |      |  |
 |      |
 |      |– sounds
 |      |  |
 |      |  |– game sounds..
 |      |  |
 |      |
 |
```

Данная архитектура является оптимальным решением для небольших проектов, поэтому именно она будет использована в нашем проекте

## Cтруктура базового класса Window

Все классы игр созданные на базе библиотеки Arcade, являются дочерними классами по отношению к классу **Window**, который представляет собой главное окно созданной игры, и содержит в себе инструменты необходимые для реализации логики игры.

Также стоит отметить, что класс **Window** предъявляет разработчикам четкие требования к внутренней структуре класса, в которую входит распределение логики по заранее заранее определенным методам. Перечень основных методов, которые присутствуют в структуре данного класса, а также краткие описания их назначения приведены ниже

- **Базовый класс Window**
  
  - Метод **setup** — служит для конфигурации игры, например инициализации спрайтов, физического движка и т.д 
  
  - Метод **on_draw** — используется для прорисовки карты и спрайтов в области окна приложения

  - Метод **on_update** — в данном методе содержится событийный цикл игры, т.е происходит проверка изменений определенных условий, и запуск указанных алгоритмов при их изменении

  - Метод **on_key_press** — служит для перехвата нажатых игроком клавиш, действует по логике прописанной в теле метода

  - Метод **on_key_release** — перехватывает события отпускания клавиши игроком, является незаменимой функцией при создании игр, подразумевающих перемещения персонажа по оси Y

## Структура класса Platformer

### Конструктор класса
В контексте класса **Platformer**, конструктор предназначен для хранения базовых констант игры, например скорости игрока (**PLAYER_SPEED**), а также инициализации атрибутов, которые хранят необходимые для функционирования игры объекты

#### Структура конструктора класса

- Метод конструктор (**__init__**)

  - Метод **super().__init__()** — используется для инициализации родительского класса **Window**, а также передачи в родительский класс таких параметров как размер главного окна и его заголовок

  - Константа **PLAYER_SPEED** — хранит значение скорости игрока
  
  - Константа **PLAYER_JUMP** — служит для хранения значения высоты прыжка игрока

  - Константа **PLAYER_SCALING** — хранит значение масштаба спрайта персонажа по отношению к тайлу

  - Константа **TILE_SCALING** — содержит значение масштаба спрайтов из макета уровня по отношению к тайлу

  - Константа **COIN_SCALING** — служит для  хранения значения масштаба спрайта монеты по отношению к тайлу

  - Константа **GRAVITY** — хранит данные о силе гравитации внутри игры, используется при инициализации физического движка
  
  - Атрибут **tilemap** — предназначен для хранения объекта импортированного макета уровня

  - Атрибут **scene** — служит для хранения объекта сцены (**Scene**)

  - Атрибут **player** — инициализирован для хранения объекта спрайта игрового персонажа

  - Атрибут **ground_list** — предназначен для хранения списка спрайтов платформ. Генерируется из слоя **ground**, необходим для обеспечения коллизии

  - Атрибут **coins_list** — служит для хранения объектов спрайтов монет, и дальнейшего удаления собранных игроком монет

  - Атрибут **player_layer** — хранит спрайт объектного слоя **Player** для определения точки спавна игрового персонажа

  - Атрибут **physics_engine** — предназначен для хранения объекта физического движка

  - Метод **set_background_color(color)** — используется для установки фона создаваемого уровня, в нашем случае это **SKY_BLUE**

  - Атрибут **coin_sound** — содержит звук, который проигрывается при сборе монет игроком

#### Код конструктора класса
```python
def __init__(self, screen_width, screen_height, screen_title):
        super().__init__(screen_width, screen_height, screen_title)
        
        # Объявляем константы игры
        self.PLAYER_SPEED = 7 # Константа хранящая значение скорости игрока
        self.PLAYER_JUMP = 15 # Константа хранящая значение высоты прыжка игрока
        self.PLAYER_SCALING = 0.9 # Константа хранящая масштаб игрока по отношению к тайлу
        
        self.TILE_SCALING = 1.0 # Константа хранящая значение гравитации внутри уровня
        self.COIN_SCALING = 0.5 # Константа для хранения значения масштаба монеты по отношению к тайлу 
        self.GRAVITY = 1 # Константа содержащая значение гравитации
        
        self.score = 0 # Атрибут служащий для хранения текущего счета игрока 
        
        self.tilemap = None # Атрибут, инициализированный для хранения объекта карты уровня
        self.scene = None # Атрибут для хранения объекта сцены 'Scene'
        self.player = None # Атрибут для хранения объекта спрайта игрока
        self.ground_list = None # Атрибут служащий для хранения спрайтов из слоя ground
        self.coins_list = None # Атрибут для хранения спрайтов из слоя coins
        self.player_layer = None # Атрибут объявленный для хранения объектного слоя Player
        self.physics_engine = None # Атрибут для храния объекта физического движка
        
        arcade.set_background_color(arcade.csscolor.SKY_BLUE) # Устаавливаем SKY_BLUE в качестве фонового цвета уровня
        
        self.coin_sound = arcade.load_sound("res/sounds/coin_sound.ogg") # Атрибут для хранения звука взятия монеты
```

### Метод setup

Данный метод запускается сразу после инициализации класса Platformer, и больше не фигурирует в работе программы. Как можно понять из названия данного метода, его основная функция заключается в конфигурации игры перед ее запуском, т.е инициализации необходимых для работы игры объектов, установки коллизий на определенные слои и т.д

#### Структура метода setup()

- Метод **setup()**

  - Атрибут **tilemap** — хранит результат выполнения метода **load_tilemap()**, который используется для импортирования карты уровня

  - Атрибут **scene** — содержит экземпляр класса **Scene**, что используется создания игровой сцены
  
  - Атрибут **player** — хранит экземпляр класса **Sprite**, который был инициализирован для импортирования спрайта персонажа

  - Атрибут **player_layer** — предназначен для хранения списка, содержащий объект устанавливающий точку спавна игрока из объектного слоя **Player**

  - Операция присваивания к атрибуту **center_x** — устанавливает позицию спрайта игрока по оси X эквивалентную позиции объекта спавна из объектного слоя **Player**

  - Операция присваивания к атрибуту **center_y** — устанавливает позицию спрайта игрока по оси Y эквивалентную позиции объекта спавна из объектного слоя **Player**

  - Метод **add_sprite()** — принадлежит экземпляру класса **Scene**. Предназначен для добавления объекта спрайта игрока в игровую сцену

  - Атрибут **ground_list** — предназначен для хранения списка спрайтов из слоя **ground**

  - Атрибут **coins_list** — служит для хранения списка спрайтов монет из слоя **coins**

  - Атрибут **physics_engine** — хранит экземпляр класса **PhysicsEnginePlatformer**, или объект физического движка платформера

#### Код метода setup()
```python
    def setup(self) -> None:
        self.tilemap = arcade.load_tilemap("res/maps/map.tmx", self.TILE_SCALING, {
            "ground": {"use_spatial_hash": True},
            "coins": {"use_spatial_hash": True}
        }) # Инициализируем атрибут для хранения карты уровня

        self.scene = arcade.Scene.from_tilemap(self.tilemap) # Присваиваем объект Scene атрибуту scene

        self.player = arcade.Sprite("res/images/player.png", self.PLAYER_SCALING) # Присваиваем атрибуту player объект Sprite
        
        self.player_layer = self.tilemap.object_lists["Player"] # Присваиваем атрибуту player_layer объектный слой

        self.player.center_x = self.player_layer[0].shape[0] # Устанавливаем начальную позицию игрока по оси X
        self.player.center_y = self.player_layer[0].shape[1] # Устанавливаем начальную позицию игрока по оси Y

        self.scene.add_sprite("Player", self.player) # Добавляем спрайт игрока в сцену
        
        self.ground_list = self.tilemap.sprite_lists["ground"] # Присваиваем слой ground атрибуту ground_list
        self.coins_list = self.tilemap.sprite_lists["coins"] # Присваиваем слой coins атрибуту coins_list

        self.physics_engine = arcade.PhysicsEnginePlatformer(self.player, walls=self.ground_list, gravity_constant=self.GRAVITY) # Присваиваем атрибуту physics_engine объект физического движка
```

### Метод on_draw

В парадигме класса **Platformer**, метод **on_draw** применяется для отрисовки спрайтов карты уровня, спрайтов персонажа, а также текущего счета игрока. В случае, если список спрайтов монет не содержит элементов, очищает игровую область окна приложения и отображает сообщение о победе игрока

#### Структура метода on_draw
- Метод **on_draw()**

  - Ветвление **if** — проверяет список спрайтов монет на наличие элементов

    - Метод **clear()** — принадлежит родительскому классу Window, служит для очищения окна приложения

    - Метод **draw()** — экземпляра класса **Scene**. Как можно понять из названия метода, используется для отрисовки сцены игрового уровня

    - Переменная **text** — хранит экземпляр класса **Text**, который служит для создания надписей с дальнейшим отображением в игровой области

    - Метод **draw()** — экземпляра класса **Text**, предназначен для отображения надписи в игровой области

  - Ответвление **else**

    - Метод **clear()** — родительского класса **Window**, используется для очищения окна игры

    - Метод **draw()** — экземпляра класса **Scene**. Используется для отрисовки игровой сцены

    - Переменная **text** — содержит экземпляр класса **Text**, с надписью о текущем счете игрока

    - Метод **draw()** — экземпляра класса **Text**, отображает надпись о счете игрока

#### Код метода on_draw()
```python
def on_draw(self) -> None:
        if len(self.coins_list) == 0: # Проверяем список спрайтов монет на наличие элементов
            self.clear()
            win_text = arcade.Text("WIN", 300, 300, arcade.csscolor.GOLD, 150) # Инициализируем атрибут хранящий надпись о победе игрока 
            win_text.draw() # Отображаем надпись о победе игрока

        else: # В случае наличия спрайтов в списке coins_list продолжаем отрисовку сцены и счета
            self.clear() # Очищаем экран приложения
            self.scene.draw() # Производим отрисовку сцены
            
            text = arcade.Text(f"Score: {self.score}", 15, 600, arcade.csscolor.GOLD, 25) # Инициализируем атрибут хранящий данные о счете игрока
            text.draw() # Отображаем текущий счет игрока
```

### Метод on_update
В контексте класса **Platformer** данный метод предназначен для обработки события столкновения спрайта персонажа, и одного из спрайтов слоя **coins**. При контакте вышеуказанных спрайтов, объекты спрайтов из слоя **coins** попадают в список сгенерированный методом **check_for_collision_with_list()**, по которому итерируется цикл for в теле метода, удаляя спрайты монет из слоя **coins**, и прибавляя единицу к счету игрока

#### Структура метода on_update()
- Метод **on_update()**

  - Метод **update()** — принадлежит экземпляру класса **PhysicsEnginePlatformer**, используется для инициации нового цикла работы физического движка

  - Цикл **for** итерирующийся в списке объектов спрайтов монет, которые были собраны игроком

    - Метод **remove_from_sprite_lists()** — предназначен для удаления спрайтов из списка сколлизировавших объектов

    - Операция присваивания к атрибуту **score** — прибавляет к счету игрока единицу за взятую монету

    - Метод **play_sound()** — служит для воспроизведения звука взятия монеты

#### Код метода on_update()
```python
    def on_update(self, delta_time) -> None:
        self.physics_engine.update() # Запускаем цикл работы физического движка
        
        for coin in arcade.check_for_collision_with_list(self.player, self.coins_list):
            coin.remove_from_sprite_lists() # Удаляем спрайт монеты если он соприкоснулся с игроком
            self.score += 1 # Прибавляем единицу к счету игрока
            arcade.play_sound(self.coin_sound) # Воспроизводим звук взятие монеты
```

### Метод on_key_press

Как было обозначено в начале текущего раздела, данный метод предназначен для перехвата и обработки нажатых игроком клавиш. В контексте нашей игры, данный метод служит для передвижения игрока, путем присваивания значений координат спрайту персонажа

#### Структура метода on_key_press()
- Метод **on_key_press()**

  - Ветвление **match:case** — отвечает за проверку значения параметра **key** при вызове метода **on_key_press**
    
     - Ответвление **arcade.key.UP** — в случае если значение параметра **key** совпадает с значением константы **arcade.key.UP**, и физический движок подтверждает, что при совершении прыжка спрайт игрока не окажется в одном из тайлов стены, увеличивает значение **Y-координаты** на значение указанное в константе **PLAYER_JUMP**

     - Ответвление **arcade.key.RIGHT** — приращает значение **X-координаты** спрайта игрока на значение указанное в константе **PLAYER_SPEED**

     - Ответвление arcade.key.LEFT — убавляет значение **X-координаты** спрайта игрока на значение указанное в константе **PLAYER_SPEED**

#### Код метода on_key_press()
```python
def on_key_press(self, key, modifiers) -> None:
        match key:
            case arcade.key.UP:
                if self.physics_engine.can_jump(): # Проверяем, может ли игрок совершить прыжок в данный момент
                    self.player.change_y = self.PLAYER_JUMP # Устанавливаем новую позицию игрока по оси Y
            
            case arcade.key.RIGHT:
                self.player.change_x = self.PLAYER_SPEED # Устанавливаем новую позицию игрока по оси X
            
            case arcade.key.LEFT:
                self.player.change_x = -self.PLAYER_SPEED # Устанавливаем новую позицию игрока по оси X
```

### Метод on_key_release

Данный метод устанавливает нулевое значение приращения **X-координаты** при условии, что значение пераметра **key** эквивалентно значениям константы **arcade.key.LEFT** или **arcade.key.RIGHT**

#### Код метода on_key_release
```python
def on_key_release(self, key, modifiers) -> None:
        if key == arcade.key.LEFT or key == arcade.key.RIGHT: 
            self.player.change_x = 0 # Устанавливаем нулевое приращение позиции по оси X, если игрок отпустил нажатую клавишу
```

# Запуск платформера

В предыдущих разделах данного руководства мы с создали макет уровня платформера в редакторе тайловых карт **Tiled Map Editor**, после чего использовали ее при создании платформера на базе библиотеки **Arcade**. 

Настало время запустить созданную ранее игру для проверки корректности работы реализованных механизмов игры. Для запуска платформера достаточно использовать одну команду вне зависимости от используемой платформы

```bash
python MarioPlatformer.py
```

После запуска платформера произойдет открытие окна игры с прорисованными спрайтами макета уровня, а также добавленным в методе **setup()** спрайтом персонажа

При использовании стрелочных клавиш можно проследить перемещение спрайта игрока со скоростью указанной в константах **PLAYER_SPEED** и **PLAYER_JUMP**

При возникновении коллизии спрайта игрока, и спрайта из слоя **coins**, последний удаляется из списка **coins_list**, после чего к счету игрока прибавляется единица, и метод **play_sound()** воспроизводит звук взятия монеты игроком

Ниже приведен ряд изображений, демонстрирующих игровой процесс платформера

![Скриншот игрового процесса](./images/gameplay_1.png)

 _Скриншот игрового процесса 1_

![Скриншот игрового процесса](./images/gameplay_2.png)

 _Скриншот игрового процесса 2_

![Скриншот игрового процесса](./images/gameplay_3.png)

 _Скриншот игрового процесса 3_
